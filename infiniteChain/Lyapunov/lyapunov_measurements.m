%% clear variables we'll be using
clear A analyticalSolution ans denominator dt eta expSigmaZ fieldStrength lyapunov1 times
clear h L n number_samples numerator oneSiteDM output R rho rho_exact state T Udt

%% Initialize state

tic
% Size of physical Hilbert Space
d=2;

% Maximum bond dimension
D = 5; 

% Initial bond dimension
chi_old=1;

 H_X=zeros(2,2,2,2);
 H_X(1,1,1,2) = 1/2;
 H_X(1,1,2,1) = 1/2;
 H_X(1,2,1,1) = 1/2;
 H_X(2,1,1,1) = 1/2;
 H_X(2,2,2,1) = 1/2;
 H_X(2,2,1,2) = 1/2;
 H_X(2,1,2,2) = 1/2;
 H_X(1,2,2,2) = 1/2;
 
 H_ZZ=zeros(2,2,2,2);
 H_ZZ(1,1,1,1) = +1;
 H_ZZ(1,2,1,2) = -1;
 H_ZZ(2,1,2,1) = -1;
 H_ZZ(2,2,2,2) = +1;
 H_ZZ=H_ZZ;

  H_Z=zeros(2,2,2,2);
 H_Z(1,1,1,1) = +1;
 H_Z(2,2,2,2) = -1;
 H_Z=H_Z;

 
% Define Hamiltonian
h=H_ZZ+0.5*H_X;


% output is the output of the TDVP time evolution
output=output;

% T is the final time
T = output{end,2};

% times is the full collection of timesteps (might not be the same).
times=output(:,2);
times=cell2mat(times);
% dt is the default timestep (might be different if you are using a
% variable timestep)
dt=0.001;

% DT is the spacing between measurements.
DT=20*dt;

% M is the total number of measurements. -50 is because the measurements
% will start some way in to the time evolution rather than t=0.

M=round(times(end)/DT)-50;

% w is used to determine the instantaneous lyapunov exponents
% w=exp(lyapunov) essentially. 
w=zeros([M,2*D^2]);

% instant_lyapunov are the instantaneous lyapunov exponents. 
instant_lyapunov=zeros([M,2*D^2]);

% lyapunov are the time averaged lyapunov exponents.
lyapunov=zeros([M,2*D^2]);

number_samples = size(output,1)-1;

% V will be the orthogonal basis vectors of our tangent space.
V=eye(2*D^2);

progressWindow = waitbar(0, 'postprocessing...');
m=0;

for n = 1:number_samples
    % Begin measuring at t=DT*50
    if round(times(n),12) >= DT*50
        
        % This if statement finds when the time is some multiple of DT.
        % Have to do it like this because timesteps might not be constant.
        if round(mod(times(n),DT),12)==0
            
            m=1+round(times(n)/DT)-50;
            
            A = output{n};
            
            [A,R,L,Trans] = normalizeMPS(A);
            
            % chi is the size of the MPS.
            chi=size(A,2);
            
            % if chi < D then the vector space generated by the V from the
            % code will be chi^2 which is smaller than D^2.
            
            % We need to embed this result in a D^2 vector space. 
            if chi < D
                V_new=eye(2*D^2);
                V_new(1:chi_old,1:chi_old)=V(1:chi_old,1:chi_old);
                V_new(end-(chi_old-1):end,1:chi_old)=V(end-(chi_old-1):end,1:chi_old);
                V_new(1:chi_old,end-(chi_old-1):end)=V(1:chi_old,end-(chi_old-1):end);
                V_new(end-(chi_old-1):end,end-(chi_old-1):end)=V(end-(chi_old-1):end,end-(chi_old-1):end);
                V=V_new;
                
            end
            V_L = leftGaugeTangentBasis(L, A, 2, chi, 8);
            
            % This calculates the objects from which we determine the
            % Lyapunov exponents. 
            % Calculate Lyapunov exponents isn't a good name but oh well..
            
            % H1 is basically <d_i psi] H [ d_j psi>
            % H2 is <d_i d_j psi] H [ psi>
            % H3 is the normalization terms from <d_i d_j psi] H [ psi>
            % when i and j are on the same site. 
            % GAMMA is the term that deals with the parallel transport.
            
            [H1,H2,H3,GAMMA]=CalculateLyapunov (A, h, R, L, V_L, chi, d);
            M1=H1+H3;
            M2=H2-GAMMA;
            
            % This is how the real matrix "SUPER_H" is formed from these
            % complex matrices. 
            SUPER_H=[imag(M1)+imag(M2), real(M1)-real(M2); -real(M1)-real(M2), imag(M1)-imag(M2)];
            
            % This might also be chi^2,chi^2 so we may need to embed in  a
            % D^2,D^2 matrix.
            if chi < D
                SUPER_H_new=eye(2*D^2);
                SUPER_H_new(1:chi_old,1:chi_old)=SUPER_H(1:chi_old,1:chi_old);
                SUPER_H_new(end-(chi_old-1):end,1:chi_old)=SUPER_H(end-(chi_old-1):end,1:chi_old);
                SUPER_H_new(1:chi_old,end-(chi_old-1):end)=SUPER_H(1:chi_old,end-(chi_old-1):end);
                SUPER_H_new(end-(chi_old-1):end,end-(chi_old-1):end)=SUPER_H(end-(chi_old-1):end,end-(chi_old-1):end);
                SUPER_H=SUPER_H_new;
                
            end
            
            % U determines how V is transformed from t to t+DT.
            U=expm(DT*SUPER_H)*V;
            
            % we QR U to find the lyapunov exponents and V_new.
            [q,r]=qr(U);
            diag(r);
            w(m,:)=diag(r);
            for i=1:2*D^2
                instant_lyapunov(m,i)=log(abs(w(m,i)))/DT;
                lyapunov(m,i)=sum(instant_lyapunov(1:m,i))/m;
                
            end
            V=q;
            
            % Sometimes the mod() function is weird so I included this to
            % catch mistakes. Doesn't seem to matter 99.99% of the time. 
        elseif round(mod(times(n),DT),12)==round(DT,12)
            fprintf('weird')
            

        % This if statement finds when the time is some multiple of DT.
        % Have to do it like this because timesteps might not be constant.
            
            m=1+round(times(n)/DT)-50;
            
            A = output{n};
            
            [A,R,L,Trans] = normalizeMPS(A);
            
            % chi is the size of the MPS.
            chi=size(A,2);
            
            % if chi < D then the vector space generated by the V from the
            % code will be chi^2 which is smaller than D^2.
            
            % We need to embed this result in a D^2 vector space. 
            if chi < D
                V_new=eye(2*D^2);
                V_new(1:chi_old,1:chi_old)=V(1:chi_old,1:chi_old);
                V_new(end-(chi_old-1):end,1:chi_old)=V(end-(chi_old-1):end,1:chi_old);
                V_new(1:chi_old,end-(chi_old-1):end)=V(1:chi_old,end-(chi_old-1):end);
                V_new(end-(chi_old-1):end,end-(chi_old-1):end)=V(end-(chi_old-1):end,end-(chi_old-1):end);
                V=V_new;
                
            end
            V_L = leftGaugeTangentBasis(L, A, 2, chi, 8);
            
            % This calculates the objects from which we determine the
            % Lyapunov exponents. 
            % Calculate Lyapunov exponents isn't a good name but oh well..
            
            % H1 is basically <d_i psi] H [ d_j psi>
            % H2 is <d_i d_j psi] H [ psi>
            % H3 is the normalization terms from <d_i d_j psi] H [ psi>
            % when i and j are on the same site. 
            % GAMMA is the term that deals with the parallel transport.
            
            [H1,H2,H3,GAMMA]=CalculateLyapunov (A, h, R, L, V_L, chi, d);
            M1=H1+H3;
            M2=H2-GAMMA;
            
            % This is how the real matrix "SUPER_H" is formed from these
            % complex matrices. 
            SUPER_H=[imag(M1)+imag(M2), real(M1)-real(M2); -real(M1)-real(M2), imag(M1)-imag(M2)];
            
            % This might also be chi^2,chi^2 so we may need to embed in  a
            % D^2,D^2 matrix.
            if chi < D
                SUPER_H_new=eye(2*D^2);
                SUPER_H_new(1:chi_old,1:chi_old)=SUPER_H(1:chi_old,1:chi_old);
                SUPER_H_new(end-(chi_old-1):end,1:chi_old)=SUPER_H(end-(chi_old-1):end,1:chi_old);
                SUPER_H_new(1:chi_old,end-(chi_old-1):end)=SUPER_H(1:chi_old,end-(chi_old-1):end);
                SUPER_H_new(end-(chi_old-1):end,end-(chi_old-1):end)=SUPER_H(end-(chi_old-1):end,end-(chi_old-1):end);
                SUPER_H=SUPER_H_new;
                
            end
            
            % U determines how V is transformed from t to t+DT.
            U=expm(DT*SUPER_H)*V;
            
            % we QR U to find the lyapunov exponents and V_new.
            [q,r]=qr(U);
            diag(r);
            w(m,:)=diag(r);
            for i=1:2*D^2
                instant_lyapunov(m,i)=log(abs(w(m,i)))/DT;
                lyapunov(m,i)=sum(instant_lyapunov(1:m,i))/m;
                
            end
            V=q;
        end
        chi_old=chi;

    end
    
    waitbar(n/number_samples)
end
close(progressWindow)



toc